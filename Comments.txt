16/01/2025

# Abstract

Great abstract! No comments.

# Acknowledgements

- who *accepted* to be my external examiner   

# Introduction

I think I lack a little bit of very high-level explanations of why modularity is important
for software engineering right at the beggining of the introduction. The introduction jumps
too quicly into Embedded DSLs. Remember that in a thesis you need to "zoom" out a bit
from your research and give an overall picture.

The introduction also has several concepts that are basically assummed without further explanation,
such as:

- shallow embeddings
- deep embeddings
- first-class classes
- ...

It is fine to talk about these, but you need to provide more background/examples so that you explain
what these are.

Generally speaking, the introduction needed to be extended mostly to provide gentler introductions
and explain certain technical concepts better (illustrated with concrete examples when needed).
Avoid assumming that the readers know all the technical
concepts that you refer to the introduction. You should aim at Computer Scientists that are not
necessarely Programming Language experts.

At the moment you have 7 pages of intro, I think that doing the zooming out + providing gentler introductions
to concepts should bring the intro to closer to the double of the size (maybe around 12-14 pages). 

# Background

## Chapter 2

- Figure 2.2: I think it is best that *all* figures are at the top of the page. Since this Figure is related to Figure
2.1 you may want to merge the 2 figures.

- (page 14 and later) You need to be clearer about how to parse -> and &. Eitther you should:

1. Specify early (before you start with the examples) which operator has precedence; or

2. You may want to insert redundant brackets to make things easier to parse for readers in several
of your inference rules/derivations. For example:

(ùê¥&ùê∂‚Üíùêµ)&(ùê¥&ùê∂‚Üíùê∑) <: ùê¥&ùê∂‚Üíùêµ&ùê∑

There are several ways to parse this, such as:

(ùê¥&(ùê∂‚Üíùêµ))&(ùê¥&(ùê∂‚Üíùê∑)) <: ùê¥&(ùê∂‚Üíùêµ)&ùê∑

((ùê¥&ùê∂)‚Üíùêµ)&((ùê¥&ùê∂)‚Üíùê∑) <: (ùê¥&ùê∂)‚Üí(ùêµ&ùê∑)

page 16:

- solution to this problem based on bidiretional typing [Dunfield and Krishnaswami 2021].
(also cite: Pierce and Turner's Local Type Inference)

- "Interaction with mutable references": You don't deliver the actual punchline here which is:
with the restriction that Ye et al. propose, both distributivity and intersection introduction can be retained without
breaking type-safety.

page 18:

- Applying it to an integer **when the expected type is known** never causes ambiguity.

I think you can give the function a name, like `f` and then show an example, like:
`f 1 + 2` and `not (f 1)`.

- A more exciting application of disjoint merges --> Another application of disjoint merges

page 20:

- right-antidistributive <- Is this an actual technical term in English? (Apparently so, as I googled it).

## Chapter 3

- while no term can be annotated with the bottom type theoretically

You can write things like:

`\x. x : Bot -> Bot`

or

`f (x : Bot) = (x : Bot)`

- using the forwarding operator ^.

Perhaps more explanation of the forwarding operator should be provided.

- Due to type-theoretic difficulties, a trait implementing a recursive type
cannot be inherited or merged with other traits in CP. **There is ongoing research
how addressing this problem.**

- Modular dependencies

One common trend during your PhD is that you mostly ignore or do not put enough
emphasis on modular dependencies. Dependency injection is an important
Software Engineering concern, for which there are not many good solutions around.
CP's modular dependencies actually provide useful mechanisms to address some
of these problems. I think your thesis should emphasize this more.
There are 0 mentions of this issue in the introduction, and here at the overview
modular dependencies are downplayed. In practice software
engineers would probably argue that depency injection is actually a significantly more
relevant problem compared to the Expression Problem.

For this chapter in particular, I think modular dependencies would deserve their own subsection
and more detailed explanations and examples, instead of being just a paragraph. In particular,
I think you should connect modular dependencies with the issue of dependency injection.

page 34:

- We would prefer to make use of type classes to decouple them in Haskell.

Actually very few Haskell programmers would do this. Maybe you could say:

We could use type classes to decouple dependencies in Haskell, but this would also
require planning in advance for the eval function to be reusable. In CP, the natural way to write
eval is already reusable, so there is no pre-planning needed to make eval reusable.

page 36:

- *Another* way is to define a repo trait with a self-type annotation:

- without *committing** to a concrete ...

20/01/2025

# Chapter 4

- The start of the chapter should give a better summary of the content
in the chapter. I see that you reused some of the text of the
introduction of the paper in the introduction, but you have not used
the text in the abstract of the paper anywhere, I think. We need to
have something like the abstract of the paper here so that the readers
can have a crisp summary of the contributions of the paper. You should
probably also include some other text from the introduction of the
paper, perhaps the one that focuses on listing the more detailed
contribution of the chapter.

Overall, the main comment is that a nice, crisp and concise summary
of what is covered in the chapter and the contributions is missing.

This should be Section 4.1, and the current 4.1 would become 4.2.

Another quick comment here is that you keep overemphasizing solving
the EP. Basically everytime you describe your work it is: we show how
to solve the EP. As I said many times before, there are many solutions
to the EP already. So, saying this, does not say that much. In the text
that we have in the paper, we emphasize various other things, which
is also what needs to be said here.

- The term linguistic reuse has never been explained, I think. It is
  mentioned in the introduction and now in this chapter, but it is not
  described. This relates to the previous point.

- For point 5 in S4.1.1, you also need to make sure you make it clear
what we mean by dependent interpretations ... I guess
these should be well-defined before we reach this text.

- Title of 4.1.6: Maybe use:

 Dependencies, Complex Interpretations, and Optimizations

 So that it fits nicely in one line.

- Figure 4.2, Table 4.1/4.2: like all other figures they should be placed at the top.

Btw, a few things to be careful when putting Figures at the top:

1. The figure should not appear in a page that comes *before* the text
that explains it. Same page or following page is ok.

2. You also need to be careful to make sure that the figure does not
come too far from the text that explains it. Sometimes, when you have
pages with many figures, a figure can be placed far away. So you need
to play with formatting, or maybe merge some figures, to avoid this.

- We have implemented an example of common subexpression elimination
  in- spired by Kiselyov [2011] (which can be found in our online
  implementation).

I think you can present this in the thesis now, since you have space.

- Section 4.4.1: I think it would be nice to have a figure here with a
  screenshot of a Minipedia page to show how it looks.

- Sections 4.4.2/4.4.3: Same as previous point. A figure would be nice.


- We need to wrap up the chapter with a small conclusion.
