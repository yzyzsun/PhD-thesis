16/01/2025

# Abstract

Great abstract! No comments.

# Acknowledgements

- who *accepted* to be my external examiner   

# Introduction

I think I lack a little bit of very high-level explanations of why modularity is important
for software engineering right at the beggining of the introduction. The introduction jumps
too quicly into Embedded DSLs. Remember that in a thesis you need to "zoom" out a bit
from your research and give an overall picture.

The introduction also has several concepts that are basically assummed without further explanation,
such as:

- shallow embeddings
- deep embeddings
- first-class classes
- ...

It is fine to talk about these, but you need to provide more background/examples so that you explain
what these are.

Generally speaking, the introduction needed to be extended mostly to provide gentler introductions
and explain certain technical concepts better (illustrated with concrete examples when needed).
Avoid assumming that the readers know all the technical
concepts that you refer to the introduction. You should aim at Computer Scientists that are not
necessarely Programming Language experts.

At the moment you have 7 pages of intro, I think that doing the zooming out + providing gentler introductions
to concepts should bring the intro to closer to the double of the size (maybe around 12-14 pages). 

# Background

## Chapter 2

- Figure 2.2: I think it is best that *all* figures are at the top of the page. Since this Figure is related to Figure
2.1 you may want to merge the 2 figures.

- (page 14 and later) You need to be clearer about how to parse -> and &. Eitther you should:

1. Specify early (before you start with the examples) which operator has precedence; or

2. You may want to insert redundant brackets to make things easier to parse for readers in several
of your inference rules/derivations. For example:

(𝐴&𝐶→𝐵)&(𝐴&𝐶→𝐷) <: 𝐴&𝐶→𝐵&𝐷

There are several ways to parse this, such as:

(𝐴&(𝐶→𝐵))&(𝐴&(𝐶→𝐷)) <: 𝐴&(𝐶→𝐵)&𝐷

((𝐴&𝐶)→𝐵)&((𝐴&𝐶)→𝐷) <: (𝐴&𝐶)→(𝐵&𝐷)

page 16:

- solution to this problem based on bidiretional typing [Dunfield and Krishnaswami 2021].
(also cite: Pierce and Turner's Local Type Inference)

- "Interaction with mutable references": You don't deliver the actual punchline here which is:
with the restriction that Ye et al. propose, both distributivity and intersection introduction can be retained without
breaking type-safety.

page 18:

- Applying it to an integer **when the expected type is known** never causes ambiguity.

I think you can give the function a name, like `f` and then show an example, like:
`f 1 + 2` and `not (f 1)`.

- A more exciting application of disjoint merges --> Another application of disjoint merges

page 20:

- right-antidistributive <- Is this an actual technical term in English? (Apparently so, as I googled it).

## Chapter 3

- while no term can be annotated with the bottom type theoretically

You can write things like:

`\x. x : Bot -> Bot`

or

`f (x : Bot) = (x : Bot)`

- using the forwarding operator ^.

Perhaps more explanation of the forwarding operator should be provided.

- Due to type-theoretic difficulties, a trait implementing a recursive type
cannot be inherited or merged with other traits in CP. **There is ongoing research
how addressing this problem.**

- Modular dependencies

One common trend during your PhD is that you mostly ignore or do not put enough
emphasis on modular dependencies. Dependency injection is an important
Software Engineering concern, for which there are not many good solutions around.
CP's modular dependencies actually provide useful mechanisms to address some
of these problems. I think your thesis should emphasize this more.
There are 0 mentions of this issue in the introduction, and here at the overview
modular dependencies are downplayed. In practice software
engineers would probably argue that depency injection is actually a significantly more
relevant problem compared to the Expression Problem.

For this chapter in particular, I think modular dependencies would deserve their own subsection
and more detailed explanations and examples, instead of being just a paragraph. In particular,
I think you should connect modular dependencies with the issue of dependency injection.

page 34:

- We would prefer to make use of type classes to decouple them in Haskell.

Actually very few Haskell programmers would do this. Maybe you could say:

We could use type classes to decouple dependencies in Haskell, but this would also
require planning in advance for the eval function to be reusable. In CP, the natural way to write
eval is already reusable, so there is no pre-planning needed to make eval reusable.

page 36:

- *Another* way is to define a repo trait with a self-type annotation:

- without *committing** to a concrete ...

