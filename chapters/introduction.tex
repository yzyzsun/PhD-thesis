\chapter{Introduction} \label{ch:introduction}

This thesis focuses on the practical aspects of \emph{compositional
programming}, which is a statically typed programming paradigm that emphasizes
modularity and extensibility, proposed by Weixin Zhang, Yaozhu Sun (the author),
and Bruno C. d. S. Oliveira \citeyearpar{zhang2021compositional}...

\section{Motivations}

Compositionality is an important principle in software engineering, meaning
that a complex system can be built by composing simpler parts. However, it is
non-trivial to achieve compositionality in practice. During the evolution of a
software system, we often need to add new features, including extending the
current system with both new data types and new operations. The \emph{expression
problem}~\citep{wadler1998expression} illustrates the difficulty of such
two-dimensional extensibility in a modular way.

\paragraph{Embedded domain-specific languages.}
The difficulty of compositionality is not only a theoretic problem, but also a
practical issue, for example, in the development of domain-specific languages
(DSLs). A common approach to defining DSLs is via a direct embedding into a host
language. This approach is used in several programming languages, such as
Haskell, Scala, and Racket. In those languages, various DSLs -- including pretty
printers~\citep{hughes1995design,wadler2003prettier}, parser
combinators~\citep{leijen2001parsec}, and property-based testing
frameworks~\citep{claessen2000quickcheck} -- are defined as embedded DSLs. There
are a few techniques for such embeddings, including the well-known
\emph{shallow} and \emph{deep} embeddings~\citep{boulton1992experience}.

Unfortunately, shallow and deep embeddings come with various trade-offs in
existing programming languages. Such trade-offs have been widely discussed in
the literature~\citep{rompf2012scala,scherr2014implicit,gibbons2014folding}. On
the one hand, the strengths of shallow embeddings are in providing
\emph{linguistic reuse}~\citep{krishnamurthi2001linguistic}, exploiting
meta-language optimizations, and allowing the addition of new DSL constructs
easily. On the other hand, deep embeddings shine in enabling the definition of
complex semantic interpretations and optimizations over the abstract syntax tree
(AST) of the DSL, and they enable adding new semantic interpretations easily.
Regarding such trade-offs, \citet{svenningsson2015combining} made the following
striking comment:

\begin{quoting}
\noindent ``The holy grail of embedded language implementation is to be able to
combine the advantages of shallow and deep in a single implementation.''
\end{quoting}

While progress has been made in embedded language implementation, the holy grail
is still not fully achieved in existing programming languages. Owing to the
trade-offs between shallow and deep embeddings, many realistic embedded DSLs end
up using a mix of both approaches in practice or more advanced forms of
embeddings. For instance, there have been several
approaches~\citep{rompf2012scala,svenningsson2015combining,jovanovic2014yinyang}
promoting the use of shallow embeddings as the frontend of the DSL to enable
linguistic reuse, while deep embeddings are used as the backend for added
flexibility in defining semantic interpretations. While such approaches manage
to alleviate some of the trade-offs, they require translations between the two
embeddings, a substantial amount of code, and some advanced coding techniques.
Alternatively, there are more advanced embedding techniques, which are inspired
by work on extensible Church encodings of algebraic data
types~\citep{hinze2006generics,oliveira2006extensible,oliveira2009modular}. Such
techniques include \emph{tagless-final
embeddings}~\citep{carette2009finally,kiselyov2010typed}, \emph{polymorphic
embeddings}~\citep{hofer2008polymorphic}, and \emph{object
algebras}~\citep{oliveira2012extensibility}, and they are able to eliminate some
of the trade-offs too. In particular, those approaches eliminate the trade-offs
with respect to extensibility, facilitating both the addition of new DSL
constructs and semantic interpretations. However, being quite close to shallow
embeddings, those approaches lack some important capabilities, such as the
ability to define complex interpretations and the use of (nested) pattern
matching to express semantic interpretations and transformations easily and
modularly.

\paragraph{Type-safe dynamic inheritance.}
In general-purpose programming languages, compositionality often requires
mechanisms of code reuse. Object-oriented programming languages usually employs
inheritance, which allows code reuse by defining new classes that inherit from
existing ones. However, traditional inheritance mechanisms have limitations. For
example, multiple inheritance can lead to the \emph{diamond problem}, where a
class inherits from two classes that have a common ancestor. This can cause
ambiguity when resolving method calls. Traits~\citep{ducasse2006traits} are a
mechanism that addresses the diamond problem by detecting ambiguous compositions
and requiring the programmer to resolve the conflicts explicitly. However, the
detection of conflicts becomes more challenging when dealing with dynamic
inheritance, where classes (or traits) can be composed at run time. This feature
can typically be found in languages with first-class
classes~\citep{takikawa2012gradual,lee2015theory}. Most statically typed
languages only provide static inheritance to achieve type safety at the cost of
flexibility.

Ideally, programming languages with dynamic inheritance and first-class classes
should have three properties:
\begin{enumerate}
\item \textbf{Flexibility.} The language should be flexible so that highly
      dynamic patterns of inheritance are allowed. Thus, it should be possible
      to support dynamic forms of mixins or traits, as well as nested classes or
      even virtual classes and family polymorphism.
\item \textbf{Reasonable efficiency and separate compilation.} For practical
      implementations, it is desirable to have a compilation model that is
      reasonably efficient and supports good software engineering properties,
      such as separate compilation.
\item \textbf{Type safety.} The language should be type-safe, so that type
      errors can be prevented statically.
\end{enumerate}
Both JavaScript and TypeScript support the 1\st and 2\nd points well. With
first-class classes, we can model dynamic inheritance, mixins, nested classes,
and even virtual
classes~\citep{madsen1989virtual,ernst2006virtual,clarke2007tribe} and family
polymorphism~\citep{ernst2001family,saito2008lightweight,zhang2017familia}.
Therefore, the inheritance model provided by JavaScript and TypeScript is
expressive and flexible. Furthermore, there has been a lot of work on optimizing
JavaScript implementations, so JavaScript and TypeScript's inheritance and class
model are reasonably efficient.

Unfortunately, for the 3\rd point, TypeScript's support for type-checking
first-class classes has a few type-soundness holes. Some of these holes, such as
the use of bivariant subtyping, are known and documented. First-class classes
bring new issues, such as a type-safety issue that we later call the
\emph{inexact superclass problem}. The inexact superclass problem can be avoided
by moving into a model based on static inheritance, which is the option widely
adopted by most mainstream languages. However, this trades flexibility for type
safety. Ideally, we want to avoid this trade-off. Retaining flexibility and type
safety while addressing the inexact superclass problem is non-trivial. In
particular, it seems to be hard with the overriding semantics of JavaScript,
which simply overrides properties that have the same name. Thus, to achieve the
three goals together, a new compilation scheme seems desirable.

\paragraph{Solving the three-fold challenge: efficient compilation for CP.}
Previous work on compositional programming has addressed the 1\st and 3\rd
points. However, no previous work has studied practical implementability
questions, such as how to have a reasonably efficient compilation model with
separate compilation. Although there is an implementation of the CP language,
this implementation is based on an interpreter. Moreover, the semantics for
compositional programming languages is based on \emph{coercive
subtyping}~\citep{luo2013coercive}, which raises immediate questions in terms of
efficiency, since upcasts have a computational cost. A naive implementation that
inserts coercions every time upcasting is needed has a prohibitive cost, which
can be \emph{orders of magnitude} slower than JavaScript programs. To fully
solve the aforementioned three-fold challenge, we need to investigate how to
compile compositional programming much more efficiently while also supporting
separate compilation.

\paragraph{Compositional programming with union types.}
The modularity and extensibility of compositional programming are supported by
intersection types from a type-theoretic perspective. It is tempting to explore
how compositional programming can be extended with union types, the dual of
intersection types. Our preliminary investigation shows that union types enable
optional arguments in CP, while named arguments are already supported by
intersection types. Named and optional arguments are prevalent features in many
existing programming
languages~\citep{garrigue2001labeled,flatt2009keyword,rytz2010named}, enhancing
code readability and flexibility. Despite widespread use, their formalization
has not been extensively studied in the literature. Especially in languages with
subtyping, such as Python and Ruby, first-class named arguments can lead to
type-safety issues. It is worthwhile to conduct a formal study of type-safe
foundations for named and optional arguments.

\section{Contribution}

\section{Organization}

\begin{description}
\item[\autoref{pt:prologue}] is the prologue. \autoref{ch:introduction}
      motivates this thesis and outlines its organization.
\item[\autoref{pt:background}] provides background information.
      \autoref{ch:background} introduces intersection and union types, merges,
      disjointness, and traits. \autoref{ch:cp} gives a crash course in the CP
      language, which implements the compositional programming paradigm.
\item[\autoref{pt:why}] explains why compositional programming matters. We
      illustrate the reasons with two applications of compositional programming
      in this part: \autoref{ch:embedding} proposes a new embedding of
      domain-specific languages; \autoref{ch:inheritance} presents a type-safe
      approach to dynamic inheritance via merging in CP.
\item[\autoref{pt:compile}] focuses on the compilation of compositional
      programming. \autoref{ch:key} describes the key ideas in our compilation
      scheme and its implementation in the CP compiler. \autoref{ch:calculi}
      formalizes a simplified version of the compilation scheme along some of
      the key ideas. \autoref{ch:compilation} explains implementation details,
      including the JavaScript code that is generated and some core
      optimizations in the CP compiler. \autoref{ch:empirical} provides an
      empirical evaluation.
\item[\autoref{pt:union}] further extends the CP language with union types.
      \autoref{ch:arguments} shows that this extension enables a type-safe
      encoding of named and optional arguments.
\item[\autoref{pt:epilogue}] is the epilogue. \autoref{ch:related} discusses
      related work, while \autoref{ch:conclusion} concludes this thesis and
      outlines future work.
\end{description}

\noindent\hrulefill

\paragraph{Prior publications.}
The main content of this thesis is based on three of my published papers.
\autoref{ch:embedding} is based on a conference paper:
\begin{itemize}
\item Yaozhu Sun, Utkarsh Dhandhania, and Bruno C.~d.~S.~Oliveira. 2022.
\textbf{Compositional Embeddings of Domain-Specific Languages}. In OOPSLA
\textit{(ACM SIGPLAN International Conference on Object-Oriented Programming
Systems, Languages, and Applications)}.
\end{itemize}
\autoref{ch:inheritance} and the whole \autoref{pt:compile} are based on a
journal paper:
\begin{itemize}
\item Yaozhu Sun, Xuejing Huang, and Bruno C.~d.~S.~Oliveira. 2025.
\textbf{Type-Safe Compilation of Dynamic Inheritance via Merging}.
\textit{ACM Transactions on Programming Languages and Systems}.
\end{itemize}
\autoref{ch:arguments} is based on another conference paper:
\begin{itemize}
\item Yaozhu Sun and Bruno C.~d.~S.~Oliveira. 2025.
\textbf{Named Arguments as Intersections, Optional Arguments as Unions}.
In ESOP \textit{(European Symposium on Programming)}.
\end{itemize}
In addition, \autoref{ch:cp} in the background part also adapts some material
about modular dependencies from my co-authored journal paper:
\begin{itemize}
\item Weixin Zhang, Yaozhu Sun, and Bruno C.~d.~S.~Oliveira. 2021.
\textbf{Compositional Programming}. \textit{ACM Transactions on Programming
Languages and Systems}.
\end{itemize}
