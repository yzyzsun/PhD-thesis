\chapter{Disjoint Intersection Types and First-Class Traits} \label{ch:background}

This part provides a brief introduction to the background of this thesis. We
first introduce intersection and union types, merging, disjointness, and traits
in this chapter, laying the type-theoretic foundation for CP. Next in
\autoref{ch:cp}, we will give a crash course in the CP language in a friendly manner.

\newcommand{\tand}{\,\&\,}
\newcommand{\tor}{\,|\,}
\newcommand{\sub}{\;<:\;}

\section{Intersection Types}

Generics or parametric polymorphism provides a mechanism for code reuse by
assigning infinite possibilities of types to a single definition. This kind of
polymorphism is \emph{uniform} in that all possibilities behave identically
despite different types instantiated.

In contrast, intersection types allows explicitly enumerating all possible types
that a single definition can have. In recently developed
theories~\citep{dunfield2014elaborating,castagna2023programming}, intersection
types are closely related to overloading or \emph{ad-hoc} polymorphism. For
example, the type of the addition operator \lstinline{(+)} for both integers and
floating-point numbers can be written as:
\begin{equation*}
(\mathbf{Int} \times \mathbf{Int} \to \mathbf{Int}) \quad\&\quad
(\mathbf{Double} \times \mathbf{Double} \to \mathbf{Double})
\end{equation*}
Note that the two versions of addition do not necessarily have the same
behavior. Semantic subtyping~\citep{frisch2008semantic} provides a
set-theoretic foundation for overloaded functions typed as intersections and is
employed in the Elixir type system~\citep{castagna2023design}.

However, this connection is not the original motivation for intersection types
(the connection did not even hold!) if we look back at the history from
1970s~\citep{bono2020tale}. Instead, functions with intersection types had
uniform behavior and could be regarded as a finite portion of parametrically
polymorphic functions. This notion is called \emph{coherent} overloading or
\emph{finitary} polymorphism~\citep{pierce1991programming}, which is a limited
form of ad-hoc polymorphism. Nevertheless, intersection types are useful for
some functions that cannot be typed in the simply typed $\lambda$-calculus (\`a
la Curry), such as the $\Omega$-combinator ($\lambda x.\ x\ x$). The
$\Omega$-combinator can be typed using the two elimination rules for
intersection types in \autoref{fig:typ-and} (\textsc{T-Abs} and \textsc{T-App}
are standard rules for functions and thus omitted):
\begin{mathpar}
\inferrule*[right=T-Abs]{\inferrule*[right=T-App]{\inferrule[T-AndElimL]{\dots}
                                                                        {x : (A \to B) \tand A \;\vdash\; x : A \to B} \\
                                                  \inferrule[T-AndElimR]{\dots}
                                                                        {x : (A \to B) \tand A \;\vdash\; x : A}}
                                                 {x : (A \to B) \tand A \;\vdash\; x\ x : B}}
                        {\cdot \vdash \lambda x.\ x\ x : (A \to B) \tand A \to B}
\end{mathpar}
Intersection types in this setting are typically used to characterize the
termination properties of $\lambda$-terms~\citep{dezani2005compositional}.
Because of the correspondence with termination, type inference with intersection
types is \emph{not} decidable; neither is type
inhabitation~\citep{urzyczyn1999emptiness}.

In light of the analogy with set intersection, it is tempting to add subtyping
to an intersection type system. \autoref{fig:sub-and} shows three subtyping
rules for intersection types, which are naturally induced by set inclusion.
Besides the subtyping rules, we also need to add the standard subsumption rule
to the typing rules in \autoref{fig:typ-and}:
\begin{mathpar}
\inferrule[T-Sub]{e : A \\ A <: B}
                 {e : B}
\end{mathpar}
With \textsc{T-Sub}, the previous elimination rules \textsc{T-AndElimL} and
\textsc{T-AndElimR} can now be derived from the subtyping rules \textsc{S-AndL}
and \textsc{S-AndR}.

\begin{figure}[t]
\begin{mathpar}
\inferrule[T-AndIntro]{e : A \\ e : B}
                      {e : A \tand B}

\inferrule[T-AndElimL]{e : A \tand B}
                      {e : A}

\inferrule[T-AndElimR]{e : A \tand B}
                      {e : B}
\end{mathpar}
\caption{Typing rules for intersection types.} \label{fig:typ-and}
\end{figure}

\begin{figure}[b]
\begin{mathpar}
\inferrule[S-AndL]{}{A \tand B \sub A}

\inferrule[S-AndR]{}{A \tand B \sub B}

\inferrule[S-And]{A <: B \\ A <: C}
                 {A \sub B \tand C}
\end{mathpar}
\caption{Subtyping rules for intersection types.} \label{fig:sub-and}
\end{figure}

\paragraph{Distributive subtyping.}
It is well known that $\lambda$-calculi have a close relationship with logical
systems~\citep{wadler2015propositions}: the Curry-Howard
isomorphism states that propositions are types and proofs are terms. An
interesting property in logic is that implication is left-distributive over
conjunction, as shown in the following equivalence:
\begin{equation*}
A \to B \land C \quad\Longleftrightarrow\quad (A \to B) \land (A \to C)
\end{equation*}
Since implication corresponds to function types and conjunction corresponds to
intersection types in our setting, the distributive property can be interpreted
as two subtyping rules:
\begin{align}
          A \to B \tand C \quad <:& \quad (A \to B) \tand (A \to C) \label{eq:dist-1} \\
(A \to B) \tand (A \to C) \quad <:& \quad A \to B \tand C \label{eq:dist-2}
\end{align}
\autoref{eq:dist-1} can be derived from the aforementioned subtyping rules for
intersection types:
\begin{mathpar}
\small
\inferrule*[right=S-And]
  {\inferrule*[left=S-Fun]{A <: A \\
                           \inferrule*[right=S-AndL]{ }
                                                    {B \tand C \sub B}}
                          {A \to B \tand C \sub A \to B} \\
   \inferrule*[right=S-Fun]{A <: A \\
                            \inferrule*[right=S-AndR]{ }
                                                     {B \tand C \sub C}}
                           {A \to B \tand C \sub A \to C}}
  {A \to B \tand C \sub (A \to B) \tand (A \to C)}
\end{mathpar}
However, \autoref{eq:dist-2} is not derivable so far. Instead, it is a key rule
of distributive subtyping, originating from the BCD type assignment
system~\citep{barendregt1983filter}. An interesting consequence of adding
\autoref{eq:dist-2} is that $(A \to B) \tand (C \to D)$ is a subtype of $A \tand
C \to B \tand D$. This can be derived as follows via transitivity:
\begin{mathpar}
\text{(I)}
\footnotesize
\inferrule*[right=S-And]{\inferrule*[left=S-AndL]{\inferrule*[left=S-Fun]{A \tand C <: A \\ B <: B}
                                                                         {A \to B \sub A \tand C \to B}}
                                                 {(A \to B) \tand (C \to D) <: A \tand C \to B} \\
                         \inferrule*[right=S-AndR]{\inferrule*[right=S-Fun]{A \tand C <: C \\ D <: D}
                                                                           {C \to D \sub A \tand C \to D}}
                                                  {(A \to B) \tand (C \to D) <: A \tand C \to D}}
                        {(A \to B) \tand (C \to D) \sub (A \tand C \to B) \tand (A \tand C \to D)}

\normalsize
\inferrule*[right=S-Trans]
  {\text{(I)}  \quad (A \to B) \tand (C \to D) \sub (A \tand C \to B) \tand (A \tand C \to D) \\
   \text{(II)} \quad (A \tand C \to B) \tand (A \tand C \to D) \sub A \tand C \to B \tand D}
  {(A \to B) \tand (C \to D) \sub A \tand C \to B \tand D}
\end{mathpar}
Judgment (I) is derivable as shown above, and Judgment (II) directly follows
\autoref{eq:dist-2}. In short, distributive subtyping allows using an
intersection of two function types as if it is a function type with the two
parameter types intersected and the two return types intersected. This form of
distributivity can be extended to record types and reveals the essence of nested
composition~\citep{bi2018essence}. As a result, family
polymorphism~\citep{ernst2001family} can be achieved, providing an elegant
solution to the expression
problem~\citep{wadler1998expression,ernst2004expression}. A detailed discussion
about family polymorphism in CP can be found in \autoref{sec:ep}.

\paragraph{Interaction with mutable references.}
Although distributive intersection subtyping is powerful, it poses a significant
challenge for type safety when mutable references are involved. In fact,
intersection subtyping alone without distributivity is already problematic.
\citet{davies2000intersection} illustrated the problem with the following
example, assuming that \lstinline[morekeywords=Pos]{Pos} (positive numbers) is a
subtype of \lstinline[morekeywords=Nat]{Nat} (natural numbers):
\begin{lstlisting}[morekeywords={Nat,Pos}]
let x = ref 48 : Ref Nat & Ref Pos in
let y = (x := 0) in    -- x is used as Ref Nat
let z = !x in z : Pos  -- x is used as Ref Pos
\end{lstlisting}
The code is well-typed but could cause a runtime error, because \lstinline{z} is
expected to be positive while it is actually a non-positive natural number
\lstinline{0}. The solution proposed by \citeauthor{davies2000intersection} is a
variant of \emph{value restriction}~\citep{wright1995simple}, which requires
that the introduction rule of intersection types (i.e. \textsc{T-AndIntro} in
\autoref{fig:typ-and}) only applies to values. By this means, \lstinline{ref 1}
cannot be typed as \lstinline[morekeywords={Nat,Pos}]{Ref Nat & Ref Pos} since
it is not a value. However, this solution does not work well with distributive
subtyping. \citeauthor{davies2000intersection} showed a similar example to the
previous one:
\begin{lstlisting}[morekeywords={Nat,Pos}]
let x = (\() -> ref 48) () : Ref Nat & Ref Pos in
let y = (x := 0) in    -- x is used as Ref Nat
let z = !x in z : Pos  -- x is used as Ref Pos
\end{lstlisting}
Since the anonymous function \lstinline{(\() -> ref 48)} is a value,
it can be typed as an intersection type
\lstinline[morekeywords={Nat,Pos}]{(() -> Ref Nat) & (() -> Ref Pos)}.
Besides, this function can be used as
\lstinline[morekeywords={Nat,Pos}]{() -> Ref Nat & Ref Pos}
via distributive subtyping. Applying it to \lstinline{()} yields almost the same
code as the previous example. To address this type-safety issue,
\citeauthor{davies2000intersection} have to drop the distributivity rule.

Recently, \citet{ye2024imperative} proposed a simpler solution to this problem
based on \emph{bidirectional typing}~\citep{dunfield2021bidirectional}.
Bidirectional type system divides traditional type assignment ($e : A$) into two
modes: type checking ($e \Leftarrow A$) and type inference ($e \Rightarrow a$).
The key idea of \citeauthor{ye2024imperative}'s solution is that the type of the
value stored in a reference can only be inferred but not checked:
\begin{mathpar}
\inferrule[T-Ref-Before]{e : A}
                 {\mathbf{ref}\ e : \mathbf{Ref}\ A}

\inferrule[T-Ref-After]{e \Rightarrow A}
                 {\mathbf{ref}\ e \Rightarrow \mathbf{Ref}\ A}
\end{mathpar}
With the rule \textsc{T-Ref-After}, \lstinline{ref 48} can only have type
\lstinline[morekeywords=Pos]{Ref Pos} because \lstinline{48} is inferred to have
type \lstinline[morekeywords=Pos]{Pos}. Morever, \lstinline{ref 48} cannot be
checked against \lstinline[morekeywords=Nat]{Ref Nat} since reference types are
invariant. As a result, the previous two examples cannot type-check in this
bidirectional type system. A final note is that, to have a reference of type
\lstinline[morekeywords=Nat]{Ref Nat} with the initial value \lstinline{48},
one can write \lstinline[morekeywords=Nat]{ref (48 : Nat)} instead.

\section{Merging and Disjointness}

In last section, we have mentioned that intersection types correspond to logical
conjunction when introducing distributive subtyping. However, this
correspondence does not apply to the original intersection type systems,
including the BCD system~\citep{barendregt1983filter}. \citet{hindley1983coppo}
gave a counterexample showing that some uninhabited intersection types are
provable in most logics. The root cause is that the introduction rule
(\textsc{T-AndIntro} in \autoref{fig:typ-and}) requires the two premises to have
the same term $e$, which is not the case in logical conjunction.
\citet{dunfield2014elaborating} proposed to add a merge construct ($e_1 \bbcomma
e_2$), where the comma\footnote{We use a single comma in this thesis instead of
double commas used by \citet{dunfield2014elaborating}. Although it is styled as
$\bbcomma$ in formulas, it is written as a plain comma \lstinline{,} in CP
code.} $(\bbcomma)$ is called the merge operator, to close the gap between
intersection types and logical conjunction. Two typing rules (\textsc{T-MergeL}
and \textsc{T-MergeR}) are added by \citeauthor{dunfield2014elaborating}, and
together with \textsc{T-AndIntro}, we can show that $e_1 \bbcomma e_2$ has type
$A \tand B$ if $e_1$ has type $A$ and $e_2$ has type $B$:
\begin{mathpar}
\inferrule*[lab=T-MergeL]{e_1 : A}
                         {e_1 \bbcomma e_2 : A}

\inferrule*[lab=T-MergeR]{e_2 : B}
                         {e_1 \bbcomma e_2 : B}

\inferrule*[right=T-AndIntro]{\inferrule*[left=T-MergL]{e_1 : A}
                                                       {e_1 \bbcomma e_2 : A} \\
                              \inferrule*[right=T-MergL]{e_2 : B}
                                                        {e_1 \bbcomma e_2 : B}}
                             {e_1 \bbcomma e_2 : A \tand B}
\end{mathpar}
The merge operator can be traced back to Forsythe, a ALGOL-like language
designed by \citet{reynolds1997design}. Merging in Forsythe is biased to avoid
semantic ambiguity. For example, if $f$ is a function, $e \bbcomma f$ will
override all function components in $e$. Consequently, merging in Forsythe
cannot be used to encode function overloading, though intersections of function
types are supported and a limited form of \emph{coherent} overloading can be
achieved. A significant outcome of merging is the ability to encode multi-field
records, where width and permutation subtyping are naturally supported via
intersection subtyping.

Contrary to Forsythe, merging in \citeauthor{dunfield2014elaborating}'s system
has the nice property of \emph{commutativity}: the order of merging does not
matter. Since there is no bias in favor of either side, semantic ambiguity
becomes an important problem. For example, applying
$(\lambda x.\ x + 1)\bbcomma(\lambda x.\ x + 2)$ to $0$ can yield either $1$ or
$2$. To address this issue, \citet{oliveira2016disjoint} require that the two
terms to be merged must have \emph{disjoint} types. A typical typing rule for
disjoint merges is as follows:
\begin{mathpar}
\inferrule[T-Merge-Disjoint]{e_1 \Rightarrow A \\ e_2 \Rightarrow B \\ A * B}
                            {e_1 \bbcomma e_2 \Rightarrow A \tand B}
\end{mathpar}
The premise $A * B$ denotes that $A$ and $B$ are disjoint. The aforementioned
example is now \emph{not} well-typed because $\mathbf{Int} \to \mathbf{Int}$ is
\emph{not} disjoint with $\mathbf{Int} \to \mathbf{Int}$ itself. More generally,
$A \to \mathbf{Int}$ is not disjoint with $B \to \mathbf{Int}$ no matter what
$A$ and $B$ are, because they have an overlapping part $A \tand B \to
\mathbf{Int}$ (or technically speaking, a common subtype). For example, consider
this overloaded function:
\begin{equation*}
(\lambda x.\ x + 1)\bbcomma(\lambda x.\ \mathbf{if}\ x\ \mathbf{then}\ 1\ \mathbf{else}\ 0)
: (\mathbf{Int} \to \mathbf{Int}) \tand (\mathbf{Bool} \to \mathbf{Int})
\end{equation*}
Applying it to $1 \bbcomma \mathbf{false}$ can yield $2$ if we choose the
left-hand side or $0$ if we choose the right-hand side. In contrast,
\emph{overloading by return type} is allowed in
\citeauthor{oliveira2016disjoint}'s system with disjoint intersection types.
For example, consider this exotically overloaded function:
\begin{equation*}
(\lambda x.\ x + 1)\bbcomma(\lambda x.\ x > 0)
: (\mathbf{Int} \to \mathbf{Int}) \tand (\mathbf{Int} \to \mathbf{Bool})
\end{equation*}
Applying it to an integer never causes ambiguity.

A more exciting application of disjoint merges is to model record concatenation.
The merge $r_1 \bbcomma r_2$ is concatenating two records if $r_1$ and $r_2$ are
non-overlapping records. The inherent difficulty of unambiguous record
concatenation with subtyping has been mentioned by
\citet{cardelli1991operations}. \citet{alpuim2017disjoint} further provide a
type-sound and coherent foundation for polymorphic record concatenation. With
parametric polymorphism, disjointness can also be used as a constraint on
quantified types, exhibiting similar expressiveness to bounded
polymorphism~\citep{xie2020row}. A detailed discussion about the interaction
among record concatenation, subtyping, and polymorphism can be found in
\autoref{sec:merge}.

\section{Union Types}

Union types are the dual concept of intersection types...

\section{Traits and Other Units of Code Reuse}

Similar to intersection types, traits are an overloaded concept in the
literature. In the CP language, we use the term \emph{trait} to refer to a
mechanism for code reuse described by \citet{ducasse2006traits}...
