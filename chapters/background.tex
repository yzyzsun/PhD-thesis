\chapter{Disjoint Intersection Types and Traits} \label{ch:background}

This part provides a brief introduction to the background of this thesis. We
first introduce intersection and union types, merging, disjointness, and traits
in this chapter, laying the type-theoretic foundation for the CP language. Next
in \autoref{ch:cp}, we will give a crash course in CP in a friendly manner.

\newcommand{\tand}{\,\&\,}
\newcommand{\tor}{\,|\,}
\newcommand{\sub}{\;<:\;}

\section{Intersection Types}

Generics or parametric polymorphism provides a mechanism for code reuse by
assigning infinite possibilities of types to a single definition. This kind of
polymorphism is \emph{uniform} in that all possibilities behave identically
despite different types instantiated.

In contrast, intersection types allows explicitly enumerating all possible types
that a single definition can have. In this thesis, intersection types are
closely related to overloading or \emph{ad-hoc} polymorphism. For example, the
type of the addition operator \lstinline{(+)} for both integers and
floating-point numbers can be written as:
\begin{equation*}
(\mathbf{Int} \to \mathbf{Int} \to \mathbf{Int}) \quad\&\quad
(\mathbf{Double} \to \mathbf{Double} \to \mathbf{Double})
\end{equation*}
Note that the two versions of addition do not necessarily have the same behavior
in this setting. Semantic subtyping~\citep{frisch2008semantic} provides a
set-theoretic foundation for overloaded functions typed as intersections and is
recently employed in the Elixir type system~\citep{castagna2023design}.

However, this connection is not the original motivation for intersection types
(the connection did not even hold!) if we look back at the history from
1970s~\citep{bono2020tale}. Instead, functions with intersection types had a
uniform behavior and could be regarded as a finite portion of parametrically
polymorphic functions. Furthermore, intersection types are useful for some terms
that cannot be typed in the simply typed $\lambda$-calculus, such as the
$\Omega$-combinator ($\lambda x.\ x\ x$). The $\Omega$-combinator can be typed
using the typing rules in \autoref{fig:typ-and} (\textsc{T-Abs} and
\textsc{T-App} are standard rules for functions and thus omitted):
\begin{mathpar}
\inferrule*[right=T-Abs]{\inferrule*[right=T-App]{\inferrule[T-AndElimL]{\dots}
                                                                        {x : (A \to B) \tand A \;\vdash\; x : A \to B} \\
                                                  \inferrule[T-AndElimR]{\dots}
                                                                        {x : (A \to B) \tand A \;\vdash\; x : A}}
                                                 {x : (A \to B) \tand A \;\vdash\; x\ x : B}}
                        {\cdot \vdash \lambda x.\ x\ x : (A \to B) \tand A \to B}
\end{mathpar}
Intersection types in this setting are typically used to characterize the
termination properties of $\lambda$-terms~\citep{dezani2005compositional}.
Because of the correspondence with termination, type inference with intersection
types is \emph{not} decidable; neither is type
inhabitation~\citep{urzyczyn1999emptiness}.

In light of the analogy with set intersection, it is tempting to add subtyping
to an intersection type system. \autoref{fig:sub-and} shows three subtyping
rules for intersection types, which are naturally induced by set inclusion.
Besides the subtyping rules, we also need to add the subsumption rule to the
typing rules in \autoref{fig:typ-and}:
\begin{mathpar}
\inferrule[T-Sub]{e : A \\ A <: B}
                 {e : B}
\end{mathpar}
With \textsc{T-Sub}, the previous elimination rules \textsc{T-AndElimL} and
\textsc{T-AndElimR} can now be derived from the subtyping rules \textsc{S-AndL}
and \textsc{S-AndR}.

\begin{figure}[t]
\begin{mathpar}
\inferrule[T-AndIntro]{e : A \\ e : B}
                      {e : A \tand B}

\inferrule[T-AndElimL]{e : A \tand B}
                      {e : A}

\inferrule[T-AndElimR]{e : A \tand B}
                      {e : B}
\end{mathpar}
\caption{Typing rules for intersection types.} \label{fig:typ-and}
\end{figure}

\begin{figure}[b]
\begin{mathpar}
\inferrule[S-AndL]{}{A \tand B \sub A}

\inferrule[S-AndR]{}{A \tand B \sub B}

\inferrule[S-And]{A <: B \\ A <: C}
                 {A \sub B \tand C}
\end{mathpar}
\caption{Subtyping rules for intersection types.} \label{fig:sub-and}
\end{figure}

\paragraph{Distributive subtyping.}
It is well known that $\lambda$-calculi have a close relationship with logical
systems~\citep{wadler2015propositions}. For example, the Curry-Howard
isomorphism states that propositions are types and proofs are terms. An
interesting property in logic is that implication is left-distributive over
conjunction, as shown in the following equivalence:
\begin{equation*}
A \to B \land C \quad\Leftrightarrow\quad (A \to B) \land (A \to C)
\end{equation*}
Since implication corresponds to function types and conjunction corresponds to
intersection types in CP, the distributive property can be translated into
two subtyping rules:
\begin{align}
          A \to B \tand C \quad <:& \quad (A \to B) \tand (A \to C) \label{eq:dist-1} \\
(A \to B) \tand (A \to C) \quad <:& \quad A \to B \tand C \label{eq:dist-2}
\end{align}
\autoref{eq:dist-1} can be derived from the aforementioned subtyping rules for
intersection types:
\begin{mathpar}
\small
\inferrule*[right=S-And]
  {\inferrule*[left=S-Fun]{A <: A \\
                           \inferrule*[right=S-AndL]{ }
                                                    {B \tand C \sub B}}
                          {A \to B \tand C \sub A \to B} \\
   \inferrule*[right=S-Fun]{A <: A \\
                            \inferrule*[right=S-AndR]{ }
                                                     {B \tand C \sub C}}
                           {A \to B \tand C \sub A \to C}}
  {A \to B \tand C \sub (A \to B) \tand (A \to C)}
\end{mathpar}
However, \autoref{eq:dist-2} is not derivable so far. Instead, it is a key rule
of distributive subtyping, originating from the BCD type assignment
system~\citep{barendregt1983filter}. An interesting consequence of adding
\autoref{eq:dist-2} is that $(A \to B) \tand (C \to D)$ is a subtype of $A \tand
C \to B \tand D$. This can be derived as follows via transitivity:
\begin{mathpar}
\text{(I)}
\footnotesize
\inferrule*[right=S-And]{\inferrule*[left=S-AndL]{\inferrule*[left=S-Fun]{A \tand C <: A \\ B <: B}
                                                                         {A \to B \sub A \tand C \to B}}
                                                 {(A \to B) \tand (C \to D) <: A \tand C \to B} \\
                         \inferrule*[right=S-AndR]{\inferrule*[right=S-Fun]{A \tand C <: C \\ D <: D}
                                                                           {C \to D \sub A \tand C \to D}}
                                                  {(A \to B) \tand (C \to D) <: A \tand C \to D}}
                        {(A \to B) \tand (C \to D) \sub (A \tand C \to B) \tand (A \tand C \to D)}

\normalsize
\inferrule*[right=S-Trans]
  {\text{(I)}  \quad (A \to B) \tand (C \to D) \sub (A \tand C \to B) \tand (A \tand C \to D) \\
   \text{(II)} \quad (A \tand C \to B) \tand (A \tand C \to D) \sub A \tand C \to B \tand D}
  {(A \to B) \tand (C \to D) \sub A \tand C \to B \tand D}
\end{mathpar}
Judgment (I) is derivable as shown above, and Judgment (II) directly follows
\autoref{eq:dist-2}. In short, distributive subtyping allows using an
intersection of two function types as if it is a function type with the two
parameter types intersected and the two return types intersected. This form of
distributivity can be extended to record types and reveals the essence of nested
composition~\citep{bi2018essence}. As a result, family
polymorphism~\citep{ernst2001family} can be achieved, providing an elegant
solution to the expression
problem~\citep{wadler1998expression,ernst2004expression}. A detailed discussion
about family polymorphism in CP can be found in \autoref{sec:ep}.

\paragraph{Interaction with mutable references.}
Although distributive intersection subtyping is powerful, it poses a significant
challenge for type safety when mutable references are involved. In fact,
intersection subtyping alone without distributivity is already problematic.
\citet{davies2000intersection} illustrated the problem with the following
example, assuming that \lstinline[morekeywords=Pos]{Pos} (positive numbers) is a
subtype of \lstinline[morekeywords=Nat]{Nat} (natural numbers):
\begin{lstlisting}[morekeywords={Nat,Pos}]
let x = ref 48 : Ref Nat & Ref Pos in
let y = (x := 0) in    -- x is used as Ref Nat
let z = !x in z : Pos  -- x is used as Ref Pos
\end{lstlisting}
The code is well-typed but could cause a runtime error, because \lstinline{z} is
expected to be positive while it is actually a non-positive number
\lstinline{0}. The solution proposed by \citeauthor{davies2000intersection} is a
variant of \emph{value restriction}~\citep{wright1995simple}, which requires
that the introduction rule of intersection types (i.e. \textsc{T-AndIntro} in
\autoref{fig:typ-and}) only applies to values. By this means, \lstinline{ref 1}
cannot be typed as \lstinline[morekeywords={Nat,Pos}]{Ref Nat & Ref Pos} since
it is not a value. However, this solution does not work well with distributive
subtyping. \citeauthor{davies2000intersection} showed a similar example to the
previous one:
\begin{lstlisting}[morekeywords={Nat,Pos}]
let x = (\(_: ()) -> ref 48) () : Ref Nat & Ref Pos in
let y = (x := 0) in    -- x is used as Ref Nat
let z = !x in z : Pos  -- x is used as Ref Pos
\end{lstlisting}
Since the anonymous function \lstinline{(\(_: ()) -> ref 48)} is a value,
it can be typed as an intersection type
\lstinline[morekeywords={Nat,Pos}]{(() -> Ref Nat) & (() -> Ref Pos)}.
Besides, this function can be used as
\lstinline[morekeywords={Nat,Pos}]{() -> Ref Nat & Ref Pos}
via distributive subtyping. Applying it to \lstinline{()} yields almost the same
code as the previous example. To address this type-safety issue,
\citeauthor{davies2000intersection} have to drop the distributivity rule.

Recently, \citet{ye2024imperative} proposed a simpler solution to this problem
based on \emph{bidirectional
typing}~\citep{pierce2000local,dunfield2021bidirectional}. Bidirectional type
system divides traditional type assignment ($e : A$) into two modes: type
checking ($e \Leftarrow A$) and type inference ($e \Rightarrow a$). The key idea
of \citeauthor{ye2024imperative}'s solution is that the type of the value stored
in a reference can only be inferred but not checked:
\begin{mathpar}
\inferrule[T-Ref-Before]{e : A}
                 {\mathbf{ref}\ e : \mathbf{Ref}\ A}

\inferrule[T-Ref-After]{e \Rightarrow A}
                 {\mathbf{ref}\ e \Rightarrow \mathbf{Ref}\ A}
\end{mathpar}
With the rule \textsc{T-Ref-After}, \lstinline{ref 48} can only have type
\lstinline[morekeywords=Pos]{Ref Pos} because \lstinline{48} is inferred to have
type \lstinline[morekeywords=Pos]{Pos}. Morever, \lstinline{ref 48} cannot be
checked against \lstinline[morekeywords=Nat]{Ref Nat} since reference types are
invariant. As a result, the previous two examples cannot type-check in this
bidirectional type system. A final note is that, to have a reference of type
\lstinline[morekeywords=Nat]{Ref Nat} with the initial value \lstinline{48},
one can write \lstinline[morekeywords=Nat]{ref (48 : Nat)} instead.

\section{Merging and Disjointness}

\section{Union Types}

\section{Traits and Other Units of Code Reuse}

Similar to intersection types, traits are an overloaded concept in the
literature. In the CP language, we use the term \emph{trait} to refer to a
mechanism for code reuse described by \citet{ducasse2006traits}...
