\chapter{A Crash Course in the CP Language} \label{ch:cp}

CP, short for \emph{compositional programming}, is a statically typed
programming language that emphasizes modularity and extensibility. It
incorporates a number of novel features in line with recent research on
compositional programming at the University of Hong Kong. These features
include:
\begin{itemize}
\item Disjoint intersection types~\citep{oliveira2016disjoint} and disjoint
      polymorphism~\citep{alpuim2017disjoint,xie2020row};
\item Distributive intersection subtyping~\citep{bi2018essence,bi2019distributive}
      and its interaction with mutable references~\citep{ye2024imperative};
\item Compositional interfaces, method patterns, and modular
      dependencies~\citep{zhang2021compositional};
\item Iso-recursive types with nominal unfoldings~\citep{zhou2022calculus};
\item Generalized record operations with type difference~\citep{xu2023making};
\item Compositional embeddings of domain-specific languages
      (\autoref{ch:embedding});
\item Dynamic inheritance (\autoref{ch:inheritance}) of first-class
      traits~\citep{bi2018typed};
\item Named and optional arguments (\autoref{ch:arguments}) via a blend of
      intersection and union types~\citep{rehman2023blend}.
\end{itemize}
Before diving into the novel features, we first introduce the basics of CP.

\section{Overview}

A CP program consists of a sequence of definitions, either for types or for
terms, and ends with a main expression to be evaluated. For example, the
following program defines a type alias \lstinline{I} and a term variable
\lstinline{i} of type \lstinline{I}, and finally evaluates \lstinline{i + 1}:
\begin{lstlisting}[xleftmargin=.3\textwidth]
type I = Int;  -- type definition
i: I = 1;      -- term definition
i + 1          -- main expression
\end{lstlisting}
Every definition must end with a semicolon.
Anything after \lstinline{--} (or within \lstinline|{- block -}|) is a comment.
Note that a type must start with an uppercase letter, while a term variable must
start with a lowercase letter. The type annotation (\lstinline{: I}) is not
required for term definitions as long as the type can be inferred.

\begin{table}[b!]
\caption{List of operators by precedence in CP.} \label{tab:op}
\centering
\begin{tabular}{*{4}{c}}
\toprule
\thead{Operators}        & \thead{Operands}                      & \thead{Arity} & \thead{Description} \\
\midrule \midrule
\texttt{-}               & \lstinline{Int} or \lstinline{Double} & Unary         & Neg. \\
\midrule
\texttt{\textsurd}       & \lstinline{Double}                    & Unary         & Sqrt. \\
\midrule
\texttt{\#}              & Arrays                                & Unary         & Length \\
\midrule
\texttt{!!}              & Arrays (lhs), \lstinline{Int} (rhs)   & Binary        & Index \\
\midrule
\texttt{* / \%}          & \lstinline{Int} or \lstinline{Double} & Binary        & Mul. \& Div. \& Mod. \\
\midrule
\texttt{+ -}             & \lstinline{Int} or \lstinline{Double} & Binary        & Add. \& Sub. \\
\midrule
\texttt{++}              & \lstinline{String} or Arrays          & Binary        & Concatenation \\
\midrule
\makecell{\texttt{== !=} \\ \texttt{< <= > >=}} & \makecell{\lstinline{Int} or \lstinline{Double} or \lstinline{String} or \lstinline{Bool} \\
                           or References}                        & Binary        & Comparison \\
                           \midrule
\texttt{\&\&}            & \lstinline{Bool}                      & Binary        & Conjunction \\
\midrule
\texttt{||}              & \lstinline{Bool}                      & Binary        & Disjunction \\
\midrule
\texttt{\^}              & Traits (lhs)                          & Binary        & Forwarding \\
\midrule
\makecell{\texttt{,} \\ \texttt{+,  ,+}} & \emph{Disjoint}       & Binary        & \makecell{Merging (Neutral, \\ Leftist, or Rightist)} \\
\midrule
\texttt{\textbackslash-} & \emph{Subtractable}                   & Binary        & Diff. \\
\midrule
\texttt{:=}              & References (lhs)                      & Binary        & Assignment \\
\midrule
\texttt{>{}>}            & Unit (lhs)                            & Binary        & Sequencing \\
\midrule
\lstinline{if then else} & \lstinline{Bool} (1st operand)        & Ternary       & Conditional \\
\bottomrule
\end{tabular}
\vskip 1ex
{\footnotesize
  lhs: left-hand side; \quad rhs: right-hand side.
}
\end{table}

\section{Primitive Types}

CP supports five primitive types and their literal forms: 
\begin{itemize}
\item \lstinline{Int}: integers, e.g. \lstinline{48}, \lstinline{-2}, \lstinline{0o77} (octal), and \lstinline{0xFF} (hexadecimal);
\item \lstinline{Double}: floating-point numbers, e.g. \lstinline{48.0} and \lstinline{-1e8} (scientific notation);
\item \lstinline{String}: strings, e.g. \lstinline{"foo \n bar"};
\item \lstinline{Bool}: booleans, either \lstinline{true} or \lstinline{false};
\item \lstinline{()}: the unit type. The unit type has only one value, also
      denoted by \lstinline{()}, and thus holds no information. It is used as
      \lstinline{null} in \autoref{ch:arguments} and as the return value of
      variable assignment.
\end{itemize}
Primitive operations on these types can be found in \autoref{tab:op}, which also
lists other operations to be introduced later.

There are also two special types originating from subtyping: \lstinline{Top} for
the top type and \lstinline{Bot} for the bottom type. They are the maximal and
minimal types in the type lattice respectively. The top type is a supertype of
any type, and the bottom type is a subtype of any type. In other words, all
terms can be annotated with the top type, while no term can be annotated with
the bottom type theoretically. However, for practical convenience,
\lstinline{undefined} can be used in any type context, including the bottom
type.

\section{Compound Types}

Compound types in CP include references, arrays, records, intersections, and
unions.

\paragraph{References.}
A reference is similar to a pointer in an imperative language. A reference type
is denoted by \lstinline{Ref T}, where \lstinline{T} is the type of the value
stored in the reference cell. Note that reference types are \emph{invariant},
meaning that \lstinline{Ref Int} is neither a subtype nor a supertype of
\lstinline{Ref Top}, in order to ensure type safety.

A reference cell can be created using the \lstinline{ref} keyword. For example,
\lstinline{ref 48} creates a cell of type \lstinline{Ref Int} with the initial
value \lstinline{48}. The value in a reference cell can be accessed using the
\lstinline{!} operator and updated using the \lstinline{:=} operator. For
example, \lstinline{r := !r - 2} updates the value in \lstinline{r} by
subtracting 2. The assignment is an expression that returns \lstinline{()}, i.e.
the unit value. Finally, \lstinline{e1 >> e2} denotes sequential composition,
which means that \lstinline{e2} is returned after \lstinline{e1} (required to
have the unit type) is executed.

\paragraph{Arrays.}
An array type is denoted by \lstinline{[T]}, where \lstinline{T} is the element
type. Since arrays are \emph{immutable} in CP, array types are treated
\emph{covariantly}. For example, \lstinline{[Int]} is a subtype of
\lstinline{[Top]} because \lstinline{Int} is a subtype of \lstinline{Top}.

\begin{tipblock}
A mutable array can be represented as an array of references, i.e.
\lstinline{[Ref T]}. Note that \lstinline{[Ref Int]} is not a subtype of
\lstinline{[Ref Top]} due to the invariance of reference types.
\end{tipblock}

\noindent
An array literal can be conveniently written as \lstinline{[e1; e2]}. Note that
we use semicolons to separate elements instead of commas because
\lstinline{e1,e2} is parsed as a merge. Two arrays can be concatenated using the
\lstinline{++} operator. The length of an array can be obtained like
\lstinline{#arr}, and the \lstinline{i}-th element can be accessed like
\lstinline{arr!!i}.

\paragraph{Records.}
A record type has the form \lstinline|{ l1: T1; l2: T2 }|, where \lstinline{l1}
and \lstinline{l2} are labels, and \lstinline{T1} and \lstinline{T2} are field
types. A record literal has the form \lstinline|{ l1 = e1; l2 = e2 }|, where
\lstinline{e1} and \lstinline{e2} are field expressions. Since there is no tuple
type in CP, a pair can be represented as a record with two fields. Record fields
can be accessed using the dot notation like \lstinline{rcd.l1}.

\begin{tipblock}
An empty record \lstinline|{}| is also allowed, which is inferred to have the
top type \lstinline{Top}. Note that \lstinline|{}| is different from the unit
value \lstinline|()|, which has the unit type \lstinline|()|.
\end{tipblock}

\noindent
Two records can be concatenated using the merge operator like \lstinline{e1,e2}.
Many other operations on records are supported via merging and type difference,
as shown in \autoref{tab:rcd}. Subtracting type \lstinline{T1} by type
\lstinline{T2} is denoted by \lstinline{T1\T2}. Taking the difference of record
types as an example, \lstinline|{ l1: Int; l2: Bool } \ { l1: Int }| is equal to
\lstinline|{ l2: Bool }|.

\begin{table}[b]
\caption{List of operations on records in CP.} \label{tab:rcd}
\centering
\begin{tabular}{ccl}
\toprule
\thead{Subtraction by Label} & \lstinline{e \ l}        & $\triangleq$\quad\lstinline|e \\ { l: Bot }| \\
\midrule
\thead{Subtraction by Type}  & \lstinline{e \\ T}       & $\triangleq$\quad\lstinline{e : T0\T}\quad if \lstinline{e} has type \lstinline{T0} \\
\midrule
\thead{Subtraction by Term}  & \lstinline{e1 \- e2}     & $\triangleq$\quad\lstinline{e1 : T1\T2}\quad if \lstinline{e1} has \lstinline{T1} and \lstinline{e2} has \lstinline{T2} \\
\midrule
\thead{Label Renaming}       & \lstinline{e [l1 <- l2]} & $\triangleq$\quad\lstinline|e\l1 , { l2 = e.l1 }| \\
\midrule
\thead{Leftist Merge}        & \lstinline{e1 +, e2}     & $\triangleq$\quad\lstinline{e1 , (e2 \- e1)} \\
\midrule
\thead{Rightist Merge}       & \lstinline{e1 ,+ e2}     & $\triangleq$\quad\lstinline{(e1 \- e2) , e2} \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Intersections.}
An intersection of types \lstinline{T1} and \lstinline{T2} is denoted by
\lstinline{T1&T2}. Intersection types have an explicit introduction form in CP,
which is called a merge and written as \lstinline{e1,e2}, where \lstinline{e1}
is an expression of type \lstinline{T1} and \lstinline{e2} is of type
\lstinline{T2}. Intersection types have no explicit elimination form, but they
can be implicitly eliminated via subtyping. For example, \lstinline{e1,e2} can
be used as if it has type \lstinline{T1} or \lstinline{T2}, because
\lstinline{T1} and \lstinline{T2} are subtypes of \lstinline{T1&T2}.

\begin{tipblock}
A multi-field record is encoded as an intersection of single-field records in
CP. For example, a record type with two fields \lstinline|{ l1: Int; l2: Bool }|
is encoded as \lstinline|{ l1: Int } & { l2: Bool }|. Similarly, at the term
level, a two-field record \lstinline|{ l1 = 48; l2 = true }| is encoded as
\lstinline|{ l1 = 48 } , { l2 = true }| using the merge operator.
\end{tipblock}

\paragraph{Unions.}
A union of types \lstinline{T1} and \lstinline{T2} is denoted by
\lstinline{T1|T2}. Union types have an explicit elimination form in CP, written
as \lstinline{switch e0 as x case T1 => e1 case T2 => e2}. Here \lstinline{x} is
a variable bound to the value of \lstinline{e0}, and it is refined to type
\lstinline{T1} in \lstinline{e1} and to \lstinline{T2} in \lstinline{e2}. Union
types have no explicit introduction form, but they can be implicitly introduced
via subtyping, e.g. \lstinline{48 : Int|()} and \lstinline{() : Int|()}.

\section{Functions}

Functions are first-class values in CP, just like in other functional languages.
A function type is written as \lstinline{T1 -> T2}, where \lstinline{T1} is the
parameter type and \lstinline{T2} is the return type. A function literal is
written as \lstinline|\(x: T1) -> e|, where \lstinline{x} is the parameter
variable and \lstinline{e} is the body expression. CP employs curried functions
to achieve multiple arguments. For example, a function of type
\lstinline{Int -> Int -> Int} can be regarded as a function that takes two
integers. For example, an addition function can be defined as follows:
\begin{lstlisting}
add (x: Int) (y: Int) = x + y;
-- is equivalent to:
add = \(x: Int) -> \(y: Int) -> x + y;
\end{lstlisting}
Higher-order functions like function composition can be defined as follows:
\begin{lstlisting}
compose (f: Int -> Int) (g: Int -> Int) (x: Int) = f (g x);
compose (\(x: Int) -> x + 1) (\(x: Int) -> x * 2) 3  --> 7
\end{lstlisting}
Unfortunately, CP does not support type inference for parameter types, so they
must be explicitly annotated as shown above. However, the return type can be
inferred for non-recursive functions. For recursive functions, the return type
must also be annotated. For example, a factorial function can be defined as
follows:
\begin{lstlisting}
fact (n: Int): Int = if n == 0 then 1 else n * fact (n - 1);
-- is equivalent to:
fact = fix fact: Int -> Int.
        \(n: Int) -> if n == 0 then 1 else n * fact (n - 1);
\end{lstlisting}
Recursive functions can be made anonymous using the \lstinline{fix} operator as
shown above.

If a local recursive function is desired rather than a top-level definition, the
\lstinline{letrec} expression can be used. For example, a tail-recursive
version of factorial can be defined as follows:
\begin{lstlisting}
fact = letrec fact' (acc: Int) (n: Int): Int =
         if n == 0 then acc else fact' (n * acc) (n - 1) in
       fact' 1;
\end{lstlisting}
Note that changing \lstinline{letrec} into \lstinline{let} will cause an error
complaining that \lstinline{fact'} is undefined, because \lstinline{let} does
not bind the variable being defined in its own definition. Nevertheless, this
behavior of \lstinline{let} can sometimes be useful for refining an existing
definition:
\begin{lstlisting}
letrec fact (acc: Int) (n: Int): Int =
  if n == 0 then acc else fact (n * acc) (n - 1) in
let fact = fact 1 in
...
\end{lstlisting}
Note that \lstinline{let fact = fact 1} is not a recursive definition. Instead,
\lstinline{fact 1} is partially applying the previously defined \lstinline{fact}
to \lstinline{1}, and the previous \lstinline{fact} is shadowed by the new
\lstinline{fact}.

\paragraph{Named and optional arguments.}
CP natively supports named and optional arguments. The syntax of function
definitions with named arguments are similar to record patterns in ML-like
languages, though CP does not support pattern matching in general. Below is an
exponential function with two named arguments:
\begin{lstlisting}
exp { x: Int; base = 10 }: Int =
  if x == 0 then 1 else base * exp { x = x - 1; base = base };
exp { base = 2; x = 15 }  --> 2^15 = 32768
exp { x = 4 }  --> 10^4 = 10000
\end{lstlisting}
The function can be called with named arguments in any order. Here
\lstinline{base} is an optional argument with a default value \lstinline{10}.
Therefore, the second call \lstinline|exp { x = 4 }| is equivalent to
\lstinline|exp { x = 4; base = 10 }| since \lstinline{base} is absent.

\section{Parametric Polymorphism}

Unlike implicit polymorphism in ML-like languages, CP employs explicit
polymorphism in System-F style. A polymorphic type is written as
\lstinline{forall A. T}, where \lstinline{A} is the type variable (must start
with an uppercase letter). A polymorphic term is written as \lstinline|/\A. e|,
and instantiating a polymorphic term \lstinline{poly} with type \lstinline{Int}
is written as \lstinline{poly @Int}.

For example, a polymorphic identity function can be defined as follows:
\begin{lstlisting}
id A (x: A) = x;
-- is equivalent to:
id = /\A. \(x: A) -> x;
\end{lstlisting}
Calling \lstinline{id @Int 48} will return \lstinline{48} as is. A more
intriguing example is a polymorphic function with \emph{disjoint
quantification}:
\begin{lstlisting}
concat R (r: R) = r , { l = 48 };  -- Type Error!
concat' (R * { l: Int }) (r: R) = r , { l = 48 };  -- OK!
\end{lstlisting}
When concatenating \lstinline{r} with a new field \lstinline|{ l = 48 }|, we
need to check whether it conflicts with any existing field in \lstinline{r}.
However, we do not know anything about \lstinline{r} if it has a totally
abstract type \lstinline{R}. That is why the first definition above is rejected
by the type checker, preventing potential field conflicts. The second definition
type-checks because the quantification \lstinline|(R * { l: Int })| indicates
that the quantified type variable \lstinline{R} is disjoint (will not overlap)
with \lstinline|{ l: Int }|, so \lstinline{r} will never have a field that
conflicts with \lstinline|{ l = 48 }|. The disjointness constraint will be
checked at the point of instantiation:
\begin{lstlisting}
concat' @{ l: Int; l': Int } { l = 46; l' = 0 }  -- Type Error!
concat' @{ l': Int } { l' = 0 }  --> { l' = 0; l = 48 }
\end{lstlisting}
The first instantiation is rejected because \lstinline|{ l: Int; l': Int }| is
not disjoint (overlaps) with \lstinline|{ l: Int }|. The second one type-checks
since the two labels \lstinline{l} and \lstinline{l'} are distinct.

\section{Compositional Traits}

CP-flavored traits are composable reuse units and are similar to classes (not
interfaces!) in traditional object-oriented languages. A trait implements an
interface by providing concrete implementations or inheriting from other traits.
A trait expression is anonymous and has the basic form \lstinline{trait => e},
where \lstinline{e} is the body expression, usually a record literal. A simple
example is shown below:
\begin{lstlisting}
type Point = { x: Int; y: Int };       -- interface (a type definition)
\end{lstlisting}
\vspace{-1ex}
\begin{lstlisting}
point (x: Int) (y: Int) =  -- trait with parameters (a term definition)
  trait implements Point => { x = x; y = y };  -- has type Trait<Point>
\end{lstlisting}
Note that traits in CP are \emph{structurally} typed, so the trait has type
\lstinline{Trait<Point>} even without declaring \lstinline{implements Point}.
The \lstinline{implements}-clause is mainly a subtyping check, ensuring that the
trait has implemented all the fields required by the interface, so we recommend
always writing it. The \lstinline{Point} interface above can be extended using
intersection types, and an extended trait can be defined by inheriting from
\lstinline{point x y}:
\begin{lstlisting}
type ColorPoint = Point & { color: String };
\end{lstlisting}
\vspace{-1ex}
\begin{lstlisting}
colorPoint (x: Int) (y: Int) (c: String) =
  trait implements ColorPoint inherits point x y => { color = c };
\end{lstlisting}
Instantiating a trait is done by the \lstinline{new} operator (the precedence of
\lstinline{new} is lower than function application):
\begin{lstlisting}
new colorPoint 0 0 "black"  --> { x = 0; y = 0; color = "black" }
\end{lstlisting}

\paragraph{Self-references.}
A more interesting example is traits with self-type annotations:
\begin{lstlisting}
type Even = { isEven: Int -> Bool };
type Odd  = { isOdd:  Int -> Bool };
\end{lstlisting}
\vspace{-1ex}
\begin{lstlisting}
even = trait [self: Odd] implements Even => {
  isEven n = if n == 0 then true else self.isOdd (n - 1);
};  -- has type Trait<Odd => Even>
\end{lstlisting}
\vspace{-1ex}
\begin{lstlisting}
odd = trait [self: Even] implements Odd => {
  isOdd n = if n == 0 then false else self.isEven (n - 1);
};  -- has type Trait<Even => Odd>
\end{lstlisting}
Here the annotations \lstinline{[self: Odd]} and \lstinline{[self: Even]} allow
the trait bodies to refer to late-bound self-references by \lstinline{self},
which is declared to have types \lstinline{Odd} and \lstinline{Even}
respectively. The trait type becomes a bit more complicated with a self-type,
written as \lstinline{Trait<In=>Out>}, where \lstinline{In} is the self-type and
\lstinline{Out} is the inferred type for the trait body (a subtype of, but not
necessarily the same as, the declared interface). Note that we do not need to
specify the type of the method parameter \lstinline{n}, for example, in
\lstinline{isEven n}, because the type can be inferred from the declared
interface \lstinline{Even}.

\begin{tipblock}
If we review the aforementioned type \lstinline{Trait<Point>}, we will find that
it is not the most precise type for the trait \lstinline{point x y}.
\lstinline{Trait<Point>} is a shorthand for \lstinline{Trait<Point => Point>} in
the latest version of CP, which is a supertype of \lstinline{Trait<Top => Point>}.
The latter is more precise because it indicates that the self-reference is not
used in the trait body (\lstinline{Top} contains no information).
\end{tipblock}

\noindent
If we try to instantiate the traits separately by \lstinline{new even} or
\lstinline{new odd}, a type error will be triggered saying that the required
interface is not satisfied (the input type is not supertype of the output type).
However, we can instantiate them together since they satisfy each other's
requirement:
\begin{lstlisting}
new even,odd  --> { isEven = ...; isOdd = ... }
\end{lstlisting}
Here \lstinline{new} is effectively obtaining a fixpoint of the merge of the two
trait, allowing late binding of the self-reference. The merge
\lstinline{even,odd} works because \lstinline{Trait<Odd=>Even> & Trait<Even=>Odd>}
can be used as \lstinline{Trait<Odd&Even>}. We see that the self-type annotations
are crucial for modular dependencies in CP.

\paragraph{Compositional interfaces and method patterns.}
Although CP does not support algebraic data types or pattern matching in a
strict sense, similar functionalities can be achieved using compositional
interfaces and method patterns.

\emph{Compositional interfaces} refer to a kind of special interfaces that
contain constructors. A compositional interface is parametrized by a
\emph{sort}, syntactically different from a normal type parameter, which serves
as the return type for the constructors.

For example, an option type can be defined as follows:
\begin{lstlisting}
type OptionSig<Option> T = {
  None: Option;
  Some: T -> Option;
};
\end{lstlisting}
The option type has two constructors: \lstinline{None} directly constructs an
option value, while \lstinline{Some} takes a value of \lstinline{T} and
constructs an option value. The sort \lstinline{<Option>} is used to indicate
the return type of the constructors. This definition is similar to a generalized
algebraic data type (GADT) in Haskell. Note that constructors must start with an
uppercase letter, instead of a lowercase letter as in normal terms.

\lstinline{OptionSig} can be implemented by implementing a concrete method as
follows:
\begin{lstlisting}
type ValueMethod T = { value: T -> T };
optional T = trait implements OptionSig<ValueMethod T> T => {
  (None).value def = def;
  (Some x).value _ = x;
};
\end{lstlisting}
This syntax is similar to pattern matching in functional languages and thus
called \emph{method patterns}. The method \lstinline{value} is defined for both
constructors \lstinline{None} and \lstinline{Some}. The method parameter
\lstinline{def} is used as a default value for \lstinline{None}, while it is
unused and replaced by a placeholder \lstinline{_} for \lstinline{Some}...

\section{Binary Methods and Recursive Types}

\section{Implementations}

There are two implementations of the CP language:
\begin{enumerate}
\item A reference interpreter bundled with the original CP
      paper~\citep{zhang2021compositional}, which is no longer maintained and is
      archived at \url{https://github.com/wxzh/CP}.
\item A new implementation including both an interpreter and a compiler to
      JavaScript, which is under active development at
      \url{https://github.com/yzyzsun/CP-next}.
\end{enumerate}
Both implementations first desugar CP source code into a core calculus called
\fiplus, and then interpret or compile the \fiplus code. The main difference
between the two interpreters is that the original one further elaborates \fiplus
to a simpler calculus called \fco~\citep{bi2019distributive} before evaluation,
while the new interpreter directly evaluates \fiplus code according to
type-directed operational semantics~\citep{huang2021taming,fan2022direct}. The
internals of the new compiler will be introduced in \autoref{pt:compile}.
