\chapter{A Crash Course in the CP Language} \label{ch:cp}

CP, short for \emph{compositional programming}, is a statically typed
programming language that emphasizes modularity and extensibility. It
incorporates a number of novel features in line with recent research on
compositional programming at the University of Hong Kong. These features
include:
\begin{itemize}
\item Disjoint intersection types~\citep{oliveira2016disjoint} and disjoint
      polymorphism~\citep{alpuim2017disjoint,xie2020row};
\item Distributive intersection subtyping~\citep{bi2018essence,bi2019distributive}
      and its interaction with mutable references~\citep{ye2024imperative};
\item Compositional interfaces, method patterns, and modular
      dependencies~\citep{zhang2021compositional};
\item Iso-recursive types with nominal unfoldings~\citep{zhou2022calculus};
\item Generalized record operations with type difference~\citep{xu2023making};
\item Compositional embeddings of domain-specific languages
      (\autoref{ch:embedding});
\item Dynamic inheritance (\autoref{ch:inheritance}) of first-class
      traits~\citep{bi2018typed};
\item Named and optional arguments (\autoref{ch:arguments}) via a blend of
      intersection and union types~\citep{rehman2023blend}.
\end{itemize}
Before diving into the novel features, we first introduce the basics of CP.

\section{Overview}

A CP program consists of a sequence of definitions, either for types or for
terms, and ends with a main expression to be evaluated. For example, the
following program defines a type alias \lstinline{I} and a term variable
\lstinline{i} of type \lstinline{I}, and finally evaluates \lstinline{i + 1}:
\begin{lstlisting}[xleftmargin=.3\textwidth]
type I = Int;  -- type definition
i: I = 1;      -- term definition
i + 1          -- main expression
\end{lstlisting}
Every definition must end with a semicolon.
Anything after \lstinline{--} (or within \lstinline|{- block -}|) is a comment.
Note that a type must start with an uppercase letter, while a term variable must
start with a lowercase letter. The type annotation (\lstinline{: I}) is not
required for term definitions as long as the type can be inferred.

\begin{table}[b!]
\caption{List of operators by precedence in CP.} \label{tab:op}
\centering
\begin{tabular}{*{4}{c}}
\toprule
\thead{Operators}        & \thead{Operands}                      & \thead{Arity} & \thead{Description} \\
\midrule \midrule
\texttt{-}               & \lstinline{Int} or \lstinline{Double} & Unary         & Neg. \\
\midrule
\texttt{\textsurd}       & \lstinline{Double}                    & Unary         & Sqrt. \\
\midrule
\texttt{\#}              & Arrays                                & Unary         & Length \\
\midrule
\texttt{!!}              & Arrays (lhs), \lstinline{Int} (rhs)   & Binary        & Index \\
\midrule
\texttt{* / \%}          & \lstinline{Int} or \lstinline{Double} & Binary        & Mul. \& Div. \& Mod. \\
\midrule
\texttt{+ -}             & \lstinline{Int} or \lstinline{Double} & Binary        & Add. \& Sub. \\
\midrule
\texttt{++}              & \lstinline{String} or Arrays          & Binary        & Concatenation \\
\midrule
\makecell{\texttt{== !=} \\ \texttt{< <= > >=}} & \makecell{\lstinline{Int} or \lstinline{Double} or \lstinline{String} or \lstinline{Bool} \\
                           or References}                        & Binary        & Comparison \\
                           \midrule
\texttt{\&\&}            & \lstinline{Bool}                      & Binary        & Conjunction \\
\midrule
\texttt{||}              & \lstinline{Bool}                      & Binary        & Disjunction \\
\midrule
\texttt{\^}              & Traits (lhs)                          & Binary        & Forwarding \\
\midrule
\makecell{\texttt{,} \\ \texttt{+,  ,+}} & \emph{Disjoint}       & Binary        & \makecell{Merging (Neutral, \\ Leftist, or Rightist)} \\
\midrule
\texttt{\textbackslash-} & \emph{Subtractable}                   & Binary        & Diff. \\
\midrule
\texttt{:=}              & References (lhs)                      & Binary        & Assignment \\
\midrule
\texttt{>{}>}            & Unit (lhs)                            & Binary        & Sequencing \\
\midrule
\lstinline{if then else} & \lstinline{Bool} (1st operand)        & Ternary       & Conditional \\
\bottomrule
\end{tabular}
\vskip 1ex
{\footnotesize
  lhs: left-hand side; \quad rhs: right-hand side.
}
\end{table}

\section{Primitive Types}

CP supports five primitive types and their literal forms: 
\begin{itemize}
\item \lstinline{Int}: integers, e.g. \lstinline{48}, \lstinline{-2}, \lstinline{0o77} (octal), and \lstinline{0xFF} (hexadecimal);
\item \lstinline{Double}: floating-point numbers, e.g. \lstinline{48.0} and \lstinline{-1e8} (scientific notation);
\item \lstinline{String}: strings, e.g. \lstinline{"foo \n bar"};
\item \lstinline{Bool}: booleans, either \lstinline{true} or \lstinline{false};
\item \lstinline{()}: the unit type. The unit type has only one value, also
      denoted by \lstinline{()}, and thus holds no information. It is used as
      \lstinline{null} in \autoref{ch:arguments} and as the return value of
      variable assignment.
\end{itemize}
Primitive operations on these types can be found in \autoref{tab:op}, which also
lists other operations to be introduced later.

There are also two special types originating from subtyping: \lstinline{Top} for
the top type and \lstinline{Bot} for the bottom type. They are the maximal and
minimal types in the type lattice respectively. The top type is a supertype of
any type, and the bottom type is a subtype of any type. In other words, all
terms can be annotated with the top type, while no term can be annotated with
the bottom type theoretically. However, for practical convenience,
\lstinline{undefined} can be used in any type context, including the bottom
type.

\section{Compound Types}

Compound types in CP include references, arrays, records, intersections, and
unions.

\paragraph{References.}
A reference is similar to a pointer in an imperative language. A reference type
is denoted by \lstinline{Ref T}, where \lstinline{T} is the type of the value
stored in the reference cell. Note that reference types are \emph{invariant},
meaning that \lstinline{Ref Int} is neither a subtype nor a supertype of
\lstinline{Ref Top}, in order to ensure type safety.

A reference cell can be created using the \lstinline{ref} keyword. For example,
\lstinline{ref 48} creates a cell of type \lstinline{Ref Int} with the initial
value \lstinline{48}. The value in a reference cell can be accessed using the
\lstinline{!} operator and updated using the \lstinline{:=} operator. For
example, \lstinline{r := !r - 2} updates the value in \lstinline{r} by
subtracting 2. The assignment is an expression that returns \lstinline{()}, i.e.
the unit value. Finally, \lstinline{e1 >> e2} denotes sequential composition,
which means that \lstinline{e2} is returned after \lstinline{e1} (required to
have the unit type) is executed.

\paragraph{Arrays.}
An array type is denoted by \lstinline{[T]}, where \lstinline{T} is the element
type. Since arrays are \emph{immutable} in CP, array types are treated
\emph{covariantly}. For example, \lstinline{[Int]} is a subtype of
\lstinline{[Top]} because \lstinline{Int} is a subtype of \lstinline{Top}.

\begin{tipblock}
A mutable array can be represented as an array of references, i.e.
\lstinline{[Ref T]}. Note that \lstinline{[Ref Int]} is not a subtype of
\lstinline{[Ref Top]} due to the invariance of reference types.
\end{tipblock}

\noindent
An array literal can be conveniently written as \lstinline{[e1; e2]}. Note that
we use semicolons to separate elements instead of commas because
\lstinline{e1,e2} is parsed as a merge. Two arrays can be concatenated using the
\lstinline{++} operator. The length of an array can be obtained like
\lstinline{#arr}, and the \lstinline{i}-th element can be accessed like
\lstinline{arr!!i}.

\paragraph{Records.}
A record type has the form \lstinline|{ l1: T1; l2: T2 }|, where \lstinline{l1}
and \lstinline{l2} are labels, and \lstinline{T1} and \lstinline{T2} are field
types. A record literal has the form \lstinline|{ l1 = e1; l2 = e2 }|, where
\lstinline{e1} and \lstinline{e2} are field expressions. Since there is no tuple
type in CP, a pair can be represented as a record with two fields. Record fields
can be accessed using the dot notation like \lstinline{rcd.l1}.

\begin{tipblock}
An empty record \lstinline|{}| is also allowed, which is inferred to have the
top type \lstinline{Top}. Note that \lstinline|{}| is different from the unit
value \lstinline|()|, which has the unit type \lstinline|()|.
\end{tipblock}

\noindent
Two records can be concatenated using the merge operator like \lstinline{e1,e2}.
Many other operations on records are supported via merging and type difference,
as shown in \autoref{tab:rcd}. Subtracting type \lstinline{T1} by type
\lstinline{T2} is denoted by \lstinline{T1\T2}. Taking the difference of record
types as an example, \lstinline|{ l1: Int; l2: Bool } \ { l1: Int }| is equal to
\lstinline|{ l2: Bool }|.

\begin{table}[b]
\caption{List of operations on records in CP.} \label{tab:rcd}
\centering
\begin{tabular}{ccl}
\toprule
\thead{Subtraction by Label} & \lstinline{e \ l}        & $\triangleq$\quad\lstinline|e \\ { l: Bot }| \\
\midrule
\thead{Subtraction by Type}  & \lstinline{e \\ T}       & $\triangleq$\quad\lstinline{e : T0\T}\quad if \lstinline{e} has type \lstinline{T0} \\
\midrule
\thead{Subtraction by Term}  & \lstinline{e1 \- e2}     & $\triangleq$\quad\lstinline{e1 : T1\T2}\quad if \lstinline{e1} has \lstinline{T1} and \lstinline{e2} has \lstinline{T2} \\
\midrule
\thead{Label Renaming}       & \lstinline{e [l1 <- l2]} & $\triangleq$\quad\lstinline|e\l1 , { l2 = e.l1 }| \\
\midrule
\thead{Leftist Merge}        & \lstinline{e1 +, e2}     & $\triangleq$\quad\lstinline{e1 , (e2 \- e1)} \\
\midrule
\thead{Rightist Merge}       & \lstinline{e1 ,+ e2}     & $\triangleq$\quad\lstinline{(e1 \- e2) , e2} \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Intersections.}
An intersection of types \lstinline{T1} and \lstinline{T2} is denoted by
\lstinline{T1&T2}. Intersection types have an explicit introduction form in CP,
which is called a merge and written as \lstinline{e1,e2}, where \lstinline{e1}
is an expression of type \lstinline{T1} and \lstinline{e2} is of type
\lstinline{T2}. Intersection types have no explicit elimination form, but they
can be implicitly eliminated via subtyping. For example, \lstinline{e1,e2} can
be used as if it has type \lstinline{T1} or \lstinline{T2}, because
\lstinline{T1} and \lstinline{T2} are subtypes of \lstinline{T1&T2}.

\begin{tipblock}
A multi-field record is encoded as an intersection of single-field records in
CP. For example, a record type with two fields \lstinline|{ l1: Int; l2: Bool }|
is encoded as \lstinline|{ l1: Int } & { l2: Bool }|. Similarly, at the term
level, a two-field record \lstinline|{ l1 = 48; l2 = true }| is encoded as
\lstinline|{ l1 = 48 } , { l2 = true }| using the merge operator.
\end{tipblock}

\paragraph{Unions.}
A union of types \lstinline{T1} and \lstinline{T2} is denoted by
\lstinline{T1|T2}. Union types have an explicit elimination form in CP, written
as \lstinline{switch e0 as x case T1 => e1 case T2 => e2}. Here \lstinline{x} is
a variable bound to the value of \lstinline{e0}, and it is refined to type
\lstinline{T1} in \lstinline{e1} and to \lstinline{T2} in \lstinline{e2}. This
mechanism is called occurrence typing or flow-sensitive typing. Union types have
no explicit introduction form, but they can be implicitly introduced via
subtyping, e.g. \lstinline{48 : Int|()} and \lstinline{() : Int|()}.

\section{Functions}

Functions are first-class values in CP, just like in other functional languages.
A function type is written as \lstinline{T1 -> T2}, where \lstinline{T1} is the
parameter type and \lstinline{T2} is the return type. A function literal is
written as \lstinline|\(x: T1) -> e|, where \lstinline{x} is the parameter
variable and \lstinline{e} is the body expression. CP employs curried functions
to achieve multiple arguments. For example, a function of type
\lstinline{Int -> Int -> Int} can be regarded as a function that takes two
integers. For example, an addition function can be defined as follows:
\begin{lstlisting}
add (x: Int) (y: Int) = x + y;
-- is equivalent to:
add = \(x: Int) -> \(y: Int) -> x + y;
\end{lstlisting}
Higher-order functions like function composition can be defined as follows:
\begin{lstlisting}
compose (f: Int -> Int) (g: Int -> Int) (x: Int) = f (g x);
compose (\(x: Int) -> x + 1) (\(x: Int) -> x * 2) 3  --> 7
\end{lstlisting}
Unfortunately, CP does not support type inference for parameter types, so they
must be explicitly annotated as shown above. However, the return type can be
inferred for non-recursive functions. For recursive functions, the return type
must also be annotated. For example, a factorial function can be defined as
follows:
\begin{lstlisting}
fact (n: Int): Int = if n == 0 then 1 else n * fact (n - 1);
-- is equivalent to:
fact = fix fact: Int -> Int.
        \(n: Int) -> if n == 0 then 1 else n * fact (n - 1);
\end{lstlisting}
Recursive functions can be made anonymous using the \lstinline{fix} operator as
shown above.

\paragraph{Named and optional arguments.}
See \autoref{ch:arguments}?

\section{Parametric Polymorphism}

Unlike implicit polymorphism in ML-like languages, CP employs explicit
polymorphism in System-F style. A polymorphic type is written as
\lstinline{forall A. T}, where \lstinline{A} is the type variable (must start
with an uppercase letter). A polymorphic term is written as \lstinline|/\A. e|,
and instantiating a polymorphic term \lstinline{poly} with type \lstinline{Int}
is written as \lstinline{poly @Int}.

For example, a polymorphic identity function can be defined as follows:
\begin{lstlisting}
id A (x: A) = x;
-- is equivalent to:
id = /\A. \(x: A) -> x;
\end{lstlisting}
Calling \lstinline{id @Int 48} will return \lstinline{48} as expected.

\section{Distributive Intersection Subtyping}

\section{Iso-Recursive Types}

Recursive types are useful for defining dynamic data structures. For example,
integer lists can be defined in Haskell as follows:
\begin{lstlisting}[language=Haskell]
data IntList = Nil | Cons Int IntList
\end{lstlisting}
This definition can be represented as $\mu \alpha.\: \mathbb{1} + \mathbb{Z}
\times \alpha$ in type theory, where $\mu$ is the least fixpoint binder. There
are two forms of recursive types in the literature: equi-recursive types and
iso-recursive types. With equi-recursive types, a recursive type is equal to its
unfolding. For example, $\mu \alpha.\: \mathbb{1} + \mathbb{Z} \times \alpha$ is
equal to $\mathbb{1} + \mathbb{Z} \times (\mu \alpha.\: \mathbb{1} + \mathbb{Z}
\times \alpha)$. However, they are distinct under iso-recursive types. Explicit
language constructs (i.e. \lstinline{fold} and \lstinline{unfold}) form an
isomorphism between the two types.

\section{Traits}

Mention a constructor name starts with an uppercase letter...
Mention laziness...

\section{Implementations}

There are two implementations of the CP language:
\begin{enumerate}
\item A reference interpreter bundled with the original CP
      paper~\citep{zhang2021compositional}, which is no longer maintained and is
      archived at \url{https://github.com/wxzh/CP}.
\item A new implementation including both an interpreter and a compiler to
      JavaScript, which is under active development at
      \url{https://github.com/yzyzsun/CP-next}.
\end{enumerate}
Both implementations first desugar CP source code into a core calculus called
\fiplus, and then interpret or compile the \fiplus code. The main difference
between the two interpreters is that the original one further elaborates \fiplus
to a simpler calculus called \fco~\citep{bi2019distributive} before evaluation,
while the new interpreter directly evaluates \fiplus code according to
type-directed operational semantics~\citep{huang2021taming,fan2022direct}. The
internals of the new compiler will be introduced in \autoref{pt:compile}.
